"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_api_sse-manager_ts"],{

/***/ "(app-pages-browser)/./lib/api/sse-manager.ts":
/*!********************************!*\
  !*** ./lib/api/sse-manager.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sseManager: () => (/* binding */ sseManager)\n/* harmony export */ });\nclass SSEManager {\n    connect(onNotification, onError) {\n        console.log(\"[SSE-Manager] connect() called, current listeners:\", this.listeners.size, \"connected:\", this.isConnected, \"connecting:\", this.isConnecting);\n        // Add listeners FIRST, before starting connection\n        // Set doesn't allow duplicates, so we don't need to check\n        this.listeners.add(onNotification);\n        if (onError) {\n            this.errorListeners.add(onError);\n        }\n        console.log(\"[SSE-Manager] After adding listener, total listeners:\", this.listeners.size);\n        // Create unsubscribe function FIRST (before any async operations)\n        const unsubscribe = ()=>{\n            console.log(\"[SSE-Manager] Unsubscribing listener, current count before:\", this.listeners.size);\n            this.listeners.delete(onNotification);\n            if (onError) {\n                this.errorListeners.delete(onError);\n            }\n            console.log(\"[SSE-Manager] After unsubscribe, listeners:\", this.listeners.size);\n            // Only disconnect if no listeners left\n            // Use longer delay to avoid race conditions when component re-renders quickly\n            if (this.listeners.size === 0) {\n                console.log(\"[SSE-Manager] No listeners left, scheduling disconnect in 500ms...\");\n                // Longer delay to avoid race conditions\n                setTimeout(()=>{\n                    // Double check - maybe a new listener was added during the delay\n                    if (this.listeners.size === 0) {\n                        console.log(\"[SSE-Manager] Confirmed no listeners, disconnecting...\");\n                        this.disconnect();\n                    } else {\n                        console.log(\"[SSE-Manager] New listener added during delay, keeping connection (listeners:\", this.listeners.size, \")\");\n                    }\n                }, 500);\n            }\n        };\n        // Start connection if not already connected or connecting\n        // Only create ONE connection regardless of how many listeners\n        // Use much longer timeout to handle React Strict Mode double-invoke cycle completely\n        if (!this.isConnected && !this.isConnecting) {\n            console.log(\"[SSE-Manager] Scheduling connection start (listeners:\", this.listeners.size, \")...\");\n            // Use longer delay (1200ms) to fully handle React Strict Mode double-invoke cycle\n            // React Strict Mode: mount → unmount → mount (takes ~200-500ms, but we need more buffer)\n            setTimeout(()=>{\n                // Double-check listeners before starting\n                if (this.listeners.size > 0 && !this.isConnected && !this.isConnecting) {\n                    console.log(\"[SSE-Manager] ✅ Starting connection now (listeners:\", this.listeners.size, \")...\");\n                    this.startConnection();\n                } else {\n                    console.log(\"[SSE-Manager] ⏭️ Skipping connection start (listeners:\", this.listeners.size, \"connected:\", this.isConnected, \"connecting:\", this.isConnecting, \")\");\n                }\n            }, 1200);\n        } else {\n            console.log(\"[SSE-Manager] Connection already exists, adding listener to existing connection (connected:\", this.isConnected, \"connecting:\", this.isConnecting, \")\");\n        }\n        // Return unsubscribe function (ALWAYS return a function)\n        console.log(\"[SSE-Manager] Returning unsubscribe function, type:\", typeof unsubscribe);\n        return unsubscribe;\n    }\n    startConnection() {\n        if (this.isConnected || this.isConnecting) {\n            console.log(\"[SSE-Manager] Already connected or connecting, skipping\");\n            return;\n        }\n        // Final check - ensure we have listeners before starting\n        if (this.listeners.size === 0) {\n            console.warn(\"[SSE-Manager] ⚠️ startConnection() called but no listeners, aborting\");\n            return;\n        }\n        const token =  true ? localStorage.getItem(\"access_token\") : 0;\n        if (!token) {\n            console.error(\"[SSE-Manager] No token available\");\n            return;\n        }\n        console.log(\"[SSE-Manager] ✅ Starting connection with\", this.listeners.size, \"listener(s)...\");\n        this.shouldReconnect = true;\n        // Call private async connectAsync() method\n        this.connectAsync();\n    }\n    async connectAsync() {\n        if (this.isConnecting || !this.shouldReconnect) {\n            console.log(\"[SSE-Manager] connect() called but already connecting or shouldReconnect=false\");\n            return;\n        }\n        // Double-check listeners before starting connection\n        // If no listeners, wait for React Strict Mode to finish\n        // Instead of aborting, we retry after a delay to handle React Strict Mode\n        if (this.listeners.size === 0) {\n            console.warn(\"[SSE-Manager] ⚠️ No listeners before starting connection, waiting 1500ms for React Strict Mode...\");\n            await new Promise((resolve)=>setTimeout(resolve, 1500));\n            if (this.listeners.size === 0) {\n                console.warn(\"[SSE-Manager] ⚠️ Still no listeners after wait - will retry connection attempt later\");\n                this.isConnecting = false;\n                // Retry connection after React Strict Mode cycle completes\n                // This ensures we don't permanently abort during development\n                setTimeout(()=>{\n                    if (this.listeners.size > 0 && !this.isConnected && !this.isConnecting) {\n                        console.log(\"[SSE-Manager] ✅ Retrying connection after React Strict Mode (listeners:\", this.listeners.size, \")\");\n                        this.startConnection();\n                    }\n                }, 2000);\n                return;\n            }\n            console.log(\"[SSE-Manager] ✅ Listeners registered after wait (count:\", this.listeners.size, \"), proceeding with connection\");\n        }\n        this.isConnecting = true;\n        this.abortController = new AbortController();\n        const token =  true ? localStorage.getItem(\"access_token\") : 0;\n        if (!token) {\n            console.error(\"[SSE-Manager] No token available\");\n            this.isConnecting = false;\n            return;\n        }\n        const url = \"\".concat(this.apiBaseUrl, \"/notifications/stream\");\n        let reconnectDelay = 1000;\n        try {\n            var _this_abortController, _response_body;\n            console.log(\"[SSE-Manager] Fetching SSE stream, listeners:\", this.listeners.size);\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    Authorization: \"Bearer \".concat(token),\n                    Accept: \"text/event-stream\"\n                },\n                signal: (_this_abortController = this.abortController) === null || _this_abortController === void 0 ? void 0 : _this_abortController.signal\n            });\n            if (!response.ok) {\n                throw new Error(\"SSE connection failed: \".concat(response.status, \" \").concat(response.statusText));\n            }\n            const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n            const decoder = new TextDecoder();\n            if (!reader) {\n                throw new Error(\"No reader available\");\n            }\n            let buffer = \"\";\n            this.isConnecting = false;\n            this.isConnected = true;\n            console.log(\"[SSE-Manager] ✅ Connected to notification stream, listeners:\", this.listeners.size);\n            reconnectDelay = 1000;\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) {\n                    console.log(\"[SSE-Manager] ⚠️ Stream ended, reconnecting in\", reconnectDelay, \"ms...\");\n                    this.isConnected = false;\n                    this.isConnecting = false;\n                    if (this.shouldReconnect && this.listeners.size > 0) {\n                        this.reconnectTimeout = setTimeout(()=>{\n                            reconnectDelay = Math.min(reconnectDelay * 2, 30000);\n                            this.connectAsync();\n                        }, reconnectDelay);\n                    }\n                    break;\n                }\n                buffer += decoder.decode(value, {\n                    stream: true\n                });\n                // Process complete events (SSE format: event: <type>\\ndata: <data>\\n\\n)\n                while(buffer.includes(\"\\n\\n\") || buffer.includes(\"\\n\") && buffer.endsWith(\"\\n\")){\n                    var _eventLines_;\n                    let eventEndIndex = buffer.indexOf(\"\\n\\n\");\n                    if (eventEndIndex === -1 && buffer.endsWith(\"\\n\")) {\n                        eventEndIndex = buffer.length - 1;\n                    }\n                    if (eventEndIndex === -1) break;\n                    const eventText = buffer.substring(0, eventEndIndex);\n                    buffer = buffer.substring(eventEndIndex + 2);\n                    let eventType = \"message\" // Default SSE event type\n                    ;\n                    let eventData = \"\";\n                    // Parse SSE format lines (split by \\n or \\r\\n)\n                    const eventLines = eventText.split(/\\r?\\n/);\n                    for(let i = 0; i < eventLines.length; i++){\n                        const line = eventLines[i];\n                        const trimmedLine = line.trim();\n                        if (!trimmedLine) continue; // Skip empty lines\n                        const lowerLine = trimmedLine.toLowerCase();\n                        // Parse event type: \"event:connected\" or \"event: connected\" (case-insensitive)\n                        if (lowerLine.startsWith(\"event:\")) {\n                            const afterColon = trimmedLine.substring(6) // After \"event:\"\n                            ;\n                            eventType = afterColon.trim();\n                            console.log(\"[SSE-Manager] 🔍 Found event type:\", eventType, \"from line:\", line.substring(0, 50));\n                            continue;\n                        }\n                        // Parse data: \"data:{\\\"message\\\":\\\"...\\\"}\" or \"data: {\\\"message\\\":\\\"...\\\"}\" (case-insensitive)\n                        if (lowerLine.startsWith(\"data:\")) {\n                            const afterColon = trimmedLine.substring(5) // After \"data:\"\n                            ;\n                            const lineData = afterColon.trim();\n                            // Handle multi-line data (join with newline)\n                            if (eventData) {\n                                eventData += \"\\n\" + lineData;\n                            } else {\n                                eventData = lineData;\n                            }\n                            console.log(\"[SSE-Manager] 🔍 Found data line:\", lineData.substring(0, 50), \"...\");\n                            continue;\n                        }\n                    // Ignore other lines (comments starting with \":\", id, retry, etc.)\n                    }\n                    // Debug: Log what we parsed\n                    console.log(\"[SSE-Manager] 📦 Parsed SSE event:\", {\n                        type: eventType,\n                        hasData: !!eventData,\n                        dataLength: eventData.length,\n                        rawLines: eventLines.length,\n                        firstLine: (_eventLines_ = eventLines[0]) === null || _eventLines_ === void 0 ? void 0 : _eventLines_.substring(0, 50),\n                        preview: eventText.substring(0, 200)\n                    });\n                    // Process event - only process if there's data\n                    if (!eventData) {\n                        // Skip events without data (like empty heartbeats or connection messages)\n                        if (eventType === \"heartbeat\" || eventType === \"connected\" || eventType === \"message\") {\n                            console.log(\"[SSE-Manager] ⏭️ Skipping empty\", eventType, \"event (no data)\");\n                        } else {\n                            console.log(\"[SSE-Manager] ⚠️ Received event with no data:\", eventType);\n                        }\n                        continue;\n                    }\n                    console.log(\"[SSE-Manager] 📥 Processing SSE event:\", {\n                        eventType,\n                        dataLength: eventData.length\n                    });\n                    if (eventType === \"notification\") {\n                        try {\n                            var _notification_message;\n                            const notification = JSON.parse(eventData);\n                            console.log(\"[SSE-Manager] 📬 Parsed notification:\", {\n                                id: notification.id,\n                                title: notification.title,\n                                message: (_notification_message = notification.message) === null || _notification_message === void 0 ? void 0 : _notification_message.substring(0, 50),\n                                category: notification.category\n                            });\n                            reconnectDelay = 1000;\n                            // Notify all listeners - use Array.from to avoid iterator issues\n                            const listenersToNotify = Array.from(this.listeners);\n                            console.log(\"[SSE-Manager] 📢 Broadcasting to\", listenersToNotify.length, \"listener(s)\");\n                            // Notify listeners synchronously to ensure immediate delivery\n                            listenersToNotify.forEach((listener)=>{\n                                try {\n                                    console.log(\"[SSE-Manager] 📤 Calling listener with notification:\", notification.id);\n                                    listener(notification);\n                                    console.log(\"[SSE-Manager] ✅ Listener called successfully\");\n                                } catch (error) {\n                                    console.error(\"[SSE-Manager] ❌ Error in listener:\", error);\n                                }\n                            });\n                        } catch (error) {\n                            console.error(\"[SSE-Manager] ❌ Parse error:\", error, \"Event data:\", eventData);\n                        }\n                    } else if (eventType === \"connected\") {\n                        console.log(\"[SSE-Manager] ✅ Server confirmed connection\");\n                        reconnectDelay = 1000;\n                    } else if (eventType === \"heartbeat\") {\n                        console.log(\"[SSE-Manager] 💓 Heartbeat received\");\n                        reconnectDelay = 1000;\n                    } else {\n                        console.log(\"[SSE-Manager] ℹ️ Unknown event type:\", eventType);\n                    }\n                }\n            }\n        } catch (error) {\n            this.isConnected = false;\n            this.isConnecting = false;\n            if (error.name !== \"AbortError\") {\n                console.error(\"[SSE-Manager] ❌ Connection error:\", error);\n                this.errorListeners.forEach((listener)=>{\n                    try {\n                        listener(error);\n                    } catch (err) {\n                        console.error(\"[SSE-Manager] Error in error listener:\", err);\n                    }\n                });\n                // Auto-reconnect on error\n                if (this.shouldReconnect && this.listeners.size > 0) {\n                    this.reconnectTimeout = setTimeout(()=>{\n                        reconnectDelay = Math.min(reconnectDelay * 2, 30000);\n                        this.connectAsync();\n                    }, reconnectDelay);\n                }\n            }\n        }\n    }\n    disconnect() {\n        this.shouldReconnect = false;\n        this.isConnected = false;\n        this.isConnecting = false;\n        if (this.abortController) {\n            this.abortController.abort();\n            this.abortController = null;\n        }\n        if (this.reconnectTimeout) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n        }\n        console.log(\"[SSE-Manager] Disconnected from notification stream\");\n    }\n    // Public method to manually disconnect (when user logs out, etc.)\n    destroy() {\n        this.listeners.clear();\n        this.errorListeners.clear();\n        this.disconnect();\n        console.log(\"[SSE-Manager] Destroyed all connections\");\n    }\n    // Check if connected\n    getConnected() {\n        return this.isConnected;\n    }\n    // Get listener count\n    getListenerCount() {\n        return this.listeners.size;\n    }\n    constructor(){\n        this.abortController = null;\n        this.reconnectTimeout = null;\n        this.shouldReconnect = true;\n        this.listeners = new Set();\n        this.errorListeners = new Set();\n        this.isConnected = false;\n        this.isConnecting = false;\n        this.apiBaseUrl = \"http://localhost:8080/api/v1\" || 0;\n    }\n}\n// Singleton instance\nconst sseManager = new SSEManager();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hcGkvc3NlLW1hbmFnZXIudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUtBLE1BQU1BO0lBY0pDLFFBQ0VDLGNBQTJCLEVBQzNCQyxPQUF1QixFQUNYO1FBQ1pDLFFBQVFDLEdBQUcsQ0FBQyxzREFBc0QsSUFBSSxDQUFDQyxTQUFTLENBQUNDLElBQUksRUFBRSxjQUFjLElBQUksQ0FBQ0MsV0FBVyxFQUFFLGVBQWUsSUFBSSxDQUFDQyxZQUFZO1FBRXZKLGtEQUFrRDtRQUNsRCwwREFBMEQ7UUFDMUQsSUFBSSxDQUFDSCxTQUFTLENBQUNJLEdBQUcsQ0FBQ1I7UUFDbkIsSUFBSUMsU0FBUztZQUNYLElBQUksQ0FBQ1EsY0FBYyxDQUFDRCxHQUFHLENBQUNQO1FBQzFCO1FBRUFDLFFBQVFDLEdBQUcsQ0FBQyx5REFBeUQsSUFBSSxDQUFDQyxTQUFTLENBQUNDLElBQUk7UUFFeEYsa0VBQWtFO1FBQ2xFLE1BQU1LLGNBQWM7WUFDbEJSLFFBQVFDLEdBQUcsQ0FBQywrREFBK0QsSUFBSSxDQUFDQyxTQUFTLENBQUNDLElBQUk7WUFDOUYsSUFBSSxDQUFDRCxTQUFTLENBQUNPLE1BQU0sQ0FBQ1g7WUFDdEIsSUFBSUMsU0FBUztnQkFDWCxJQUFJLENBQUNRLGNBQWMsQ0FBQ0UsTUFBTSxDQUFDVjtZQUM3QjtZQUNBQyxRQUFRQyxHQUFHLENBQUMsK0NBQStDLElBQUksQ0FBQ0MsU0FBUyxDQUFDQyxJQUFJO1lBRTlFLHVDQUF1QztZQUN2Qyw4RUFBOEU7WUFDOUUsSUFBSSxJQUFJLENBQUNELFNBQVMsQ0FBQ0MsSUFBSSxLQUFLLEdBQUc7Z0JBQzdCSCxRQUFRQyxHQUFHLENBQUM7Z0JBQ1osd0NBQXdDO2dCQUN4Q1MsV0FBVztvQkFDVCxpRUFBaUU7b0JBQ2pFLElBQUksSUFBSSxDQUFDUixTQUFTLENBQUNDLElBQUksS0FBSyxHQUFHO3dCQUM3QkgsUUFBUUMsR0FBRyxDQUFDO3dCQUNaLElBQUksQ0FBQ1UsVUFBVTtvQkFD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aS9zc2UtbWFuYWdlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE5vdGlmaWNhdGlvbiB9IGZyb20gXCJAL3R5cGVzXCJcblxudHlwZSBTU0VMaXN0ZW5lciA9IChub3RpZmljYXRpb246IE5vdGlmaWNhdGlvbikgPT4gdm9pZFxudHlwZSBFcnJvckxpc3RlbmVyID0gKGVycm9yOiBFdmVudCB8IEVycm9yKSA9PiB2b2lkXG5cbmNsYXNzIFNTRU1hbmFnZXIge1xuICBwcml2YXRlIGFib3J0Q29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSByZWNvbm5lY3RUaW1lb3V0OiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgc2hvdWxkUmVjb25uZWN0ID0gdHJ1ZVxuICBwcml2YXRlIGxpc3RlbmVyczogU2V0PFNTRUxpc3RlbmVyPiA9IG5ldyBTZXQoKVxuICBwcml2YXRlIGVycm9yTGlzdGVuZXJzOiBTZXQ8RXJyb3JMaXN0ZW5lcj4gPSBuZXcgU2V0KClcbiAgcHJpdmF0ZSBpc0Nvbm5lY3RlZCA9IGZhbHNlXG4gIHByaXZhdGUgaXNDb25uZWN0aW5nID0gZmFsc2VcbiAgcHJpdmF0ZSBhcGlCYXNlVXJsOiBzdHJpbmdcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmFwaUJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDo4MDgwL2FwaS92MVwiXG4gIH1cblxuICBjb25uZWN0KFxuICAgIG9uTm90aWZpY2F0aW9uOiBTU0VMaXN0ZW5lcixcbiAgICBvbkVycm9yPzogRXJyb3JMaXN0ZW5lclxuICApOiAoKSA9PiB2b2lkIHtcbiAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0gY29ubmVjdCgpIGNhbGxlZCwgY3VycmVudCBsaXN0ZW5lcnM6XCIsIHRoaXMubGlzdGVuZXJzLnNpemUsIFwiY29ubmVjdGVkOlwiLCB0aGlzLmlzQ29ubmVjdGVkLCBcImNvbm5lY3Rpbmc6XCIsIHRoaXMuaXNDb25uZWN0aW5nKVxuICAgIFxuICAgIC8vIEFkZCBsaXN0ZW5lcnMgRklSU1QsIGJlZm9yZSBzdGFydGluZyBjb25uZWN0aW9uXG4gICAgLy8gU2V0IGRvZXNuJ3QgYWxsb3cgZHVwbGljYXRlcywgc28gd2UgZG9uJ3QgbmVlZCB0byBjaGVja1xuICAgIHRoaXMubGlzdGVuZXJzLmFkZChvbk5vdGlmaWNhdGlvbilcbiAgICBpZiAob25FcnJvcikge1xuICAgICAgdGhpcy5lcnJvckxpc3RlbmVycy5hZGQob25FcnJvcilcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0gQWZ0ZXIgYWRkaW5nIGxpc3RlbmVyLCB0b3RhbCBsaXN0ZW5lcnM6XCIsIHRoaXMubGlzdGVuZXJzLnNpemUpXG5cbiAgICAvLyBDcmVhdGUgdW5zdWJzY3JpYmUgZnVuY3Rpb24gRklSU1QgKGJlZm9yZSBhbnkgYXN5bmMgb3BlcmF0aW9ucylcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSBVbnN1YnNjcmliaW5nIGxpc3RlbmVyLCBjdXJyZW50IGNvdW50IGJlZm9yZTpcIiwgdGhpcy5saXN0ZW5lcnMuc2l6ZSlcbiAgICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShvbk5vdGlmaWNhdGlvbilcbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIHRoaXMuZXJyb3JMaXN0ZW5lcnMuZGVsZXRlKG9uRXJyb3IpXG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0gQWZ0ZXIgdW5zdWJzY3JpYmUsIGxpc3RlbmVyczpcIiwgdGhpcy5saXN0ZW5lcnMuc2l6ZSlcbiAgICAgIFxuICAgICAgLy8gT25seSBkaXNjb25uZWN0IGlmIG5vIGxpc3RlbmVycyBsZWZ0XG4gICAgICAvLyBVc2UgbG9uZ2VyIGRlbGF5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9ucyB3aGVuIGNvbXBvbmVudCByZS1yZW5kZXJzIHF1aWNrbHlcbiAgICAgIGlmICh0aGlzLmxpc3RlbmVycy5zaXplID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSBObyBsaXN0ZW5lcnMgbGVmdCwgc2NoZWR1bGluZyBkaXNjb25uZWN0IGluIDUwMG1zLi4uXCIpXG4gICAgICAgIC8vIExvbmdlciBkZWxheSB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgLy8gRG91YmxlIGNoZWNrIC0gbWF5YmUgYSBuZXcgbGlzdGVuZXIgd2FzIGFkZGVkIGR1cmluZyB0aGUgZGVsYXlcbiAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIENvbmZpcm1lZCBubyBsaXN0ZW5lcnMsIGRpc2Nvbm5lY3RpbmcuLi5cIilcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSBOZXcgbGlzdGVuZXIgYWRkZWQgZHVyaW5nIGRlbGF5LCBrZWVwaW5nIGNvbm5lY3Rpb24gKGxpc3RlbmVyczpcIiwgdGhpcy5saXN0ZW5lcnMuc2l6ZSwgXCIpXCIpXG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MDApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgY29ubmVjdGlvbiBpZiBub3QgYWxyZWFkeSBjb25uZWN0ZWQgb3IgY29ubmVjdGluZ1xuICAgIC8vIE9ubHkgY3JlYXRlIE9ORSBjb25uZWN0aW9uIHJlZ2FyZGxlc3Mgb2YgaG93IG1hbnkgbGlzdGVuZXJzXG4gICAgLy8gVXNlIG11Y2ggbG9uZ2VyIHRpbWVvdXQgdG8gaGFuZGxlIFJlYWN0IFN0cmljdCBNb2RlIGRvdWJsZS1pbnZva2UgY3ljbGUgY29tcGxldGVseVxuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCAmJiAhdGhpcy5pc0Nvbm5lY3RpbmcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSBTY2hlZHVsaW5nIGNvbm5lY3Rpb24gc3RhcnQgKGxpc3RlbmVyczpcIiwgdGhpcy5saXN0ZW5lcnMuc2l6ZSwgXCIpLi4uXCIpXG4gICAgICAvLyBVc2UgbG9uZ2VyIGRlbGF5ICgxMjAwbXMpIHRvIGZ1bGx5IGhhbmRsZSBSZWFjdCBTdHJpY3QgTW9kZSBkb3VibGUtaW52b2tlIGN5Y2xlXG4gICAgICAvLyBSZWFjdCBTdHJpY3QgTW9kZTogbW91bnQg4oaSIHVubW91bnQg4oaSIG1vdW50ICh0YWtlcyB+MjAwLTUwMG1zLCBidXQgd2UgbmVlZCBtb3JlIGJ1ZmZlcilcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyBEb3VibGUtY2hlY2sgbGlzdGVuZXJzIGJlZm9yZSBzdGFydGluZ1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnMuc2l6ZSA+IDAgJiYgIXRoaXMuaXNDb25uZWN0ZWQgJiYgIXRoaXMuaXNDb25uZWN0aW5nKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIOKchSBTdGFydGluZyBjb25uZWN0aW9uIG5vdyAobGlzdGVuZXJzOlwiLCB0aGlzLmxpc3RlbmVycy5zaXplLCBcIikuLi5cIilcbiAgICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdGlvbigpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIOKPre+4jyBTa2lwcGluZyBjb25uZWN0aW9uIHN0YXJ0IChsaXN0ZW5lcnM6XCIsIHRoaXMubGlzdGVuZXJzLnNpemUsIFwiY29ubmVjdGVkOlwiLCB0aGlzLmlzQ29ubmVjdGVkLCBcImNvbm5lY3Rpbmc6XCIsIHRoaXMuaXNDb25uZWN0aW5nLCBcIilcIilcbiAgICAgICAgfVxuICAgICAgfSwgMTIwMClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIENvbm5lY3Rpb24gYWxyZWFkeSBleGlzdHMsIGFkZGluZyBsaXN0ZW5lciB0byBleGlzdGluZyBjb25uZWN0aW9uIChjb25uZWN0ZWQ6XCIsIHRoaXMuaXNDb25uZWN0ZWQsIFwiY29ubmVjdGluZzpcIiwgdGhpcy5pc0Nvbm5lY3RpbmcsIFwiKVwiKVxuICAgIH1cblxuICAgIC8vIFJldHVybiB1bnN1YnNjcmliZSBmdW5jdGlvbiAoQUxXQVlTIHJldHVybiBhIGZ1bmN0aW9uKVxuICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSBSZXR1cm5pbmcgdW5zdWJzY3JpYmUgZnVuY3Rpb24sIHR5cGU6XCIsIHR5cGVvZiB1bnN1YnNjcmliZSlcbiAgICByZXR1cm4gdW5zdWJzY3JpYmVcbiAgfVxuXG4gIHByaXZhdGUgc3RhcnRDb25uZWN0aW9uKCkge1xuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkIHx8IHRoaXMuaXNDb25uZWN0aW5nKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0gQWxyZWFkeSBjb25uZWN0ZWQgb3IgY29ubmVjdGluZywgc2tpcHBpbmdcIilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEZpbmFsIGNoZWNrIC0gZW5zdXJlIHdlIGhhdmUgbGlzdGVuZXJzIGJlZm9yZSBzdGFydGluZ1xuICAgIGlmICh0aGlzLmxpc3RlbmVycy5zaXplID09PSAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbU1NFLU1hbmFnZXJdIOKaoO+4jyBzdGFydENvbm5lY3Rpb24oKSBjYWxsZWQgYnV0IG5vIGxpc3RlbmVycywgYWJvcnRpbmdcIilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRva2VuID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiYWNjZXNzX3Rva2VuXCIpIDogbnVsbFxuICAgIGlmICghdG9rZW4pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbU1NFLU1hbmFnZXJdIE5vIHRva2VuIGF2YWlsYWJsZVwiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIOKchSBTdGFydGluZyBjb25uZWN0aW9uIHdpdGhcIiwgdGhpcy5saXN0ZW5lcnMuc2l6ZSwgXCJsaXN0ZW5lcihzKS4uLlwiKVxuICAgIHRoaXMuc2hvdWxkUmVjb25uZWN0ID0gdHJ1ZVxuICAgIC8vIENhbGwgcHJpdmF0ZSBhc3luYyBjb25uZWN0QXN5bmMoKSBtZXRob2RcbiAgICB0aGlzLmNvbm5lY3RBc3luYygpXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNvbm5lY3RBc3luYygpIHtcbiAgICBpZiAodGhpcy5pc0Nvbm5lY3RpbmcgfHwgIXRoaXMuc2hvdWxkUmVjb25uZWN0KSB7XG4gICAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0gY29ubmVjdCgpIGNhbGxlZCBidXQgYWxyZWFkeSBjb25uZWN0aW5nIG9yIHNob3VsZFJlY29ubmVjdD1mYWxzZVwiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gRG91YmxlLWNoZWNrIGxpc3RlbmVycyBiZWZvcmUgc3RhcnRpbmcgY29ubmVjdGlvblxuICAgIC8vIElmIG5vIGxpc3RlbmVycywgd2FpdCBmb3IgUmVhY3QgU3RyaWN0IE1vZGUgdG8gZmluaXNoXG4gICAgLy8gSW5zdGVhZCBvZiBhYm9ydGluZywgd2UgcmV0cnkgYWZ0ZXIgYSBkZWxheSB0byBoYW5kbGUgUmVhY3QgU3RyaWN0IE1vZGVcbiAgICBpZiAodGhpcy5saXN0ZW5lcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1NTRS1NYW5hZ2VyXSDimqDvuI8gTm8gbGlzdGVuZXJzIGJlZm9yZSBzdGFydGluZyBjb25uZWN0aW9uLCB3YWl0aW5nIDE1MDBtcyBmb3IgUmVhY3QgU3RyaWN0IE1vZGUuLi5cIilcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxNTAwKSlcbiAgICAgIFxuICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1NTRS1NYW5hZ2VyXSDimqDvuI8gU3RpbGwgbm8gbGlzdGVuZXJzIGFmdGVyIHdhaXQgLSB3aWxsIHJldHJ5IGNvbm5lY3Rpb24gYXR0ZW1wdCBsYXRlclwiKVxuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlXG4gICAgICAgIC8vIFJldHJ5IGNvbm5lY3Rpb24gYWZ0ZXIgUmVhY3QgU3RyaWN0IE1vZGUgY3ljbGUgY29tcGxldGVzXG4gICAgICAgIC8vIFRoaXMgZW5zdXJlcyB3ZSBkb24ndCBwZXJtYW5lbnRseSBhYm9ydCBkdXJpbmcgZGV2ZWxvcG1lbnRcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLnNpemUgPiAwICYmICF0aGlzLmlzQ29ubmVjdGVkICYmICF0aGlzLmlzQ29ubmVjdGluZykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIOKchSBSZXRyeWluZyBjb25uZWN0aW9uIGFmdGVyIFJlYWN0IFN0cmljdCBNb2RlIChsaXN0ZW5lcnM6XCIsIHRoaXMubGlzdGVuZXJzLnNpemUsIFwiKVwiKVxuICAgICAgICAgICAgdGhpcy5zdGFydENvbm5lY3Rpb24oKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwMClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0g4pyFIExpc3RlbmVycyByZWdpc3RlcmVkIGFmdGVyIHdhaXQgKGNvdW50OlwiLCB0aGlzLmxpc3RlbmVycy5zaXplLCBcIiksIHByb2NlZWRpbmcgd2l0aCBjb25uZWN0aW9uXCIpXG4gICAgfVxuXG5cbiAgICB0aGlzLmlzQ29ubmVjdGluZyA9IHRydWVcbiAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIGNvbnN0IHRva2VuID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiYWNjZXNzX3Rva2VuXCIpIDogbnVsbFxuICAgIGlmICghdG9rZW4pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbU1NFLU1hbmFnZXJdIE5vIHRva2VuIGF2YWlsYWJsZVwiKVxuICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlCYXNlVXJsfS9ub3RpZmljYXRpb25zL3N0cmVhbWBcbiAgICBsZXQgcmVjb25uZWN0RGVsYXkgPSAxMDAwXG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIEZldGNoaW5nIFNTRSBzdHJlYW0sIGxpc3RlbmVyczpcIiwgdGhpcy5saXN0ZW5lcnMuc2l6ZSlcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAgIEFjY2VwdDogXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiLFxuICAgICAgICB9LFxuICAgICAgICBzaWduYWw6IHRoaXMuYWJvcnRDb250cm9sbGVyPy5zaWduYWwsXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU1NFIGNvbm5lY3Rpb24gZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHk/LmdldFJlYWRlcigpXG4gICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcblxuICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVhZGVyIGF2YWlsYWJsZVwiKVxuICAgICAgfVxuXG4gICAgICBsZXQgYnVmZmVyID0gXCJcIlxuICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRydWVcbiAgICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSDinIUgQ29ubmVjdGVkIHRvIG5vdGlmaWNhdGlvbiBzdHJlYW0sIGxpc3RlbmVyczpcIiwgdGhpcy5saXN0ZW5lcnMuc2l6ZSlcblxuICAgICAgcmVjb25uZWN0RGVsYXkgPSAxMDAwXG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKClcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0g4pqg77iPIFN0cmVhbSBlbmRlZCwgcmVjb25uZWN0aW5nIGluXCIsIHJlY29ubmVjdERlbGF5LCBcIm1zLi4uXCIpXG4gICAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgICAgIGlmICh0aGlzLnNob3VsZFJlY29ubmVjdCAmJiB0aGlzLmxpc3RlbmVycy5zaXplID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHJlY29ubmVjdERlbGF5ID0gTWF0aC5taW4ocmVjb25uZWN0RGVsYXkgKiAyLCAzMDAwMClcbiAgICAgICAgICAgICAgdGhpcy5jb25uZWN0QXN5bmMoKVxuICAgICAgICAgICAgfSwgcmVjb25uZWN0RGVsYXkpXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBidWZmZXIgKz0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pXG5cbiAgICAgICAgLy8gUHJvY2VzcyBjb21wbGV0ZSBldmVudHMgKFNTRSBmb3JtYXQ6IGV2ZW50OiA8dHlwZT5cXG5kYXRhOiA8ZGF0YT5cXG5cXG4pXG4gICAgICAgIHdoaWxlIChidWZmZXIuaW5jbHVkZXMoXCJcXG5cXG5cIikgfHwgKGJ1ZmZlci5pbmNsdWRlcyhcIlxcblwiKSAmJiBidWZmZXIuZW5kc1dpdGgoXCJcXG5cIikpKSB7XG4gICAgICAgICAgbGV0IGV2ZW50RW5kSW5kZXggPSBidWZmZXIuaW5kZXhPZihcIlxcblxcblwiKVxuICAgICAgICAgIGlmIChldmVudEVuZEluZGV4ID09PSAtMSAmJiBidWZmZXIuZW5kc1dpdGgoXCJcXG5cIikpIHtcbiAgICAgICAgICAgIGV2ZW50RW5kSW5kZXggPSBidWZmZXIubGVuZ3RoIC0gMVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChldmVudEVuZEluZGV4ID09PSAtMSkgYnJlYWtcblxuICAgICAgICAgIGNvbnN0IGV2ZW50VGV4dCA9IGJ1ZmZlci5zdWJzdHJpbmcoMCwgZXZlbnRFbmRJbmRleClcbiAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc3Vic3RyaW5nKGV2ZW50RW5kSW5kZXggKyAyKVxuXG4gICAgICAgICAgbGV0IGV2ZW50VHlwZSA9IFwibWVzc2FnZVwiIC8vIERlZmF1bHQgU1NFIGV2ZW50IHR5cGVcbiAgICAgICAgICBsZXQgZXZlbnREYXRhID0gXCJcIlxuXG4gICAgICAgICAgLy8gUGFyc2UgU1NFIGZvcm1hdCBsaW5lcyAoc3BsaXQgYnkgXFxuIG9yIFxcclxcbilcbiAgICAgICAgICBjb25zdCBldmVudExpbmVzID0gZXZlbnRUZXh0LnNwbGl0KC9cXHI/XFxuLylcbiAgICAgICAgICBcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBldmVudExpbmVzW2ldXG4gICAgICAgICAgICBjb25zdCB0cmltbWVkTGluZSA9IGxpbmUudHJpbSgpXG4gICAgICAgICAgICBpZiAoIXRyaW1tZWRMaW5lKSBjb250aW51ZSAvLyBTa2lwIGVtcHR5IGxpbmVzXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGxvd2VyTGluZSA9IHRyaW1tZWRMaW5lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUGFyc2UgZXZlbnQgdHlwZTogXCJldmVudDpjb25uZWN0ZWRcIiBvciBcImV2ZW50OiBjb25uZWN0ZWRcIiAoY2FzZS1pbnNlbnNpdGl2ZSlcbiAgICAgICAgICAgIGlmIChsb3dlckxpbmUuc3RhcnRzV2l0aChcImV2ZW50OlwiKSkge1xuICAgICAgICAgICAgICBjb25zdCBhZnRlckNvbG9uID0gdHJpbW1lZExpbmUuc3Vic3RyaW5nKDYpIC8vIEFmdGVyIFwiZXZlbnQ6XCJcbiAgICAgICAgICAgICAgZXZlbnRUeXBlID0gYWZ0ZXJDb2xvbi50cmltKClcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIPCflI0gRm91bmQgZXZlbnQgdHlwZTpcIiwgZXZlbnRUeXBlLCBcImZyb20gbGluZTpcIiwgbGluZS5zdWJzdHJpbmcoMCwgNTApKVxuICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBQYXJzZSBkYXRhOiBcImRhdGE6e1xcXCJtZXNzYWdlXFxcIjpcXFwiLi4uXFxcIn1cIiBvciBcImRhdGE6IHtcXFwibWVzc2FnZVxcXCI6XFxcIi4uLlxcXCJ9XCIgKGNhc2UtaW5zZW5zaXRpdmUpXG4gICAgICAgICAgICBpZiAobG93ZXJMaW5lLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgICAgICAgICAgICBjb25zdCBhZnRlckNvbG9uID0gdHJpbW1lZExpbmUuc3Vic3RyaW5nKDUpIC8vIEFmdGVyIFwiZGF0YTpcIlxuICAgICAgICAgICAgICBjb25zdCBsaW5lRGF0YSA9IGFmdGVyQ29sb24udHJpbSgpXG4gICAgICAgICAgICAgIC8vIEhhbmRsZSBtdWx0aS1saW5lIGRhdGEgKGpvaW4gd2l0aCBuZXdsaW5lKVxuICAgICAgICAgICAgICBpZiAoZXZlbnREYXRhKSB7XG4gICAgICAgICAgICAgICAgZXZlbnREYXRhICs9IFwiXFxuXCIgKyBsaW5lRGF0YVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50RGF0YSA9IGxpbmVEYXRhXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIPCflI0gRm91bmQgZGF0YSBsaW5lOlwiLCBsaW5lRGF0YS5zdWJzdHJpbmcoMCwgNTApLCBcIi4uLlwiKVxuICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZ25vcmUgb3RoZXIgbGluZXMgKGNvbW1lbnRzIHN0YXJ0aW5nIHdpdGggXCI6XCIsIGlkLCByZXRyeSwgZXRjLilcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRGVidWc6IExvZyB3aGF0IHdlIHBhcnNlZFxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSDwn5OmIFBhcnNlZCBTU0UgZXZlbnQ6XCIsIHtcbiAgICAgICAgICAgIHR5cGU6IGV2ZW50VHlwZSxcbiAgICAgICAgICAgIGhhc0RhdGE6ICEhZXZlbnREYXRhLFxuICAgICAgICAgICAgZGF0YUxlbmd0aDogZXZlbnREYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIHJhd0xpbmVzOiBldmVudExpbmVzLmxlbmd0aCxcbiAgICAgICAgICAgIGZpcnN0TGluZTogZXZlbnRMaW5lc1swXT8uc3Vic3RyaW5nKDAsIDUwKSxcbiAgICAgICAgICAgIHByZXZpZXc6IGV2ZW50VGV4dC5zdWJzdHJpbmcoMCwgMjAwKSxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgLy8gUHJvY2VzcyBldmVudCAtIG9ubHkgcHJvY2VzcyBpZiB0aGVyZSdzIGRhdGFcbiAgICAgICAgICBpZiAoIWV2ZW50RGF0YSkge1xuICAgICAgICAgICAgLy8gU2tpcCBldmVudHMgd2l0aG91dCBkYXRhIChsaWtlIGVtcHR5IGhlYXJ0YmVhdHMgb3IgY29ubmVjdGlvbiBtZXNzYWdlcylcbiAgICAgICAgICAgIGlmIChldmVudFR5cGUgPT09IFwiaGVhcnRiZWF0XCIgfHwgZXZlbnRUeXBlID09PSBcImNvbm5lY3RlZFwiIHx8IGV2ZW50VHlwZSA9PT0gXCJtZXNzYWdlXCIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIOKPre+4jyBTa2lwcGluZyBlbXB0eVwiLCBldmVudFR5cGUsIFwiZXZlbnQgKG5vIGRhdGEpXCIpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0g4pqg77iPIFJlY2VpdmVkIGV2ZW50IHdpdGggbm8gZGF0YTpcIiwgZXZlbnRUeXBlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIPCfk6UgUHJvY2Vzc2luZyBTU0UgZXZlbnQ6XCIsIHsgZXZlbnRUeXBlLCBkYXRhTGVuZ3RoOiBldmVudERhdGEubGVuZ3RoIH0pXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gXCJub3RpZmljYXRpb25cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uID0gSlNPTi5wYXJzZShldmVudERhdGEpIGFzIE5vdGlmaWNhdGlvblxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0g8J+TrCBQYXJzZWQgbm90aWZpY2F0aW9uOlwiLCB7XG4gICAgICAgICAgICAgICAgaWQ6IG5vdGlmaWNhdGlvbi5pZCxcbiAgICAgICAgICAgICAgICB0aXRsZTogbm90aWZpY2F0aW9uLnRpdGxlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG5vdGlmaWNhdGlvbi5tZXNzYWdlPy5zdWJzdHJpbmcoMCwgNTApLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiBub3RpZmljYXRpb24uY2F0ZWdvcnksXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIHJlY29ubmVjdERlbGF5ID0gMTAwMFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gTm90aWZ5IGFsbCBsaXN0ZW5lcnMgLSB1c2UgQXJyYXkuZnJvbSB0byBhdm9pZCBpdGVyYXRvciBpc3N1ZXNcbiAgICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzVG9Ob3RpZnkgPSBBcnJheS5mcm9tKHRoaXMubGlzdGVuZXJzKVxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0g8J+ToiBCcm9hZGNhc3RpbmcgdG9cIiwgbGlzdGVuZXJzVG9Ob3RpZnkubGVuZ3RoLCBcImxpc3RlbmVyKHMpXCIpXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBOb3RpZnkgbGlzdGVuZXJzIHN5bmNocm9ub3VzbHkgdG8gZW5zdXJlIGltbWVkaWF0ZSBkZWxpdmVyeVxuICAgICAgICAgICAgICBsaXN0ZW5lcnNUb05vdGlmeS5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0g8J+TpCBDYWxsaW5nIGxpc3RlbmVyIHdpdGggbm90aWZpY2F0aW9uOlwiLCBub3RpZmljYXRpb24uaWQpXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lcihub3RpZmljYXRpb24pXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0g4pyFIExpc3RlbmVyIGNhbGxlZCBzdWNjZXNzZnVsbHlcIilcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltTU0UtTWFuYWdlcl0g4p2MIEVycm9yIGluIGxpc3RlbmVyOlwiLCBlcnJvcilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW1NTRS1NYW5hZ2VyXSDinYwgUGFyc2UgZXJyb3I6XCIsIGVycm9yLCBcIkV2ZW50IGRhdGE6XCIsIGV2ZW50RGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIOKchSBTZXJ2ZXIgY29uZmlybWVkIGNvbm5lY3Rpb25cIilcbiAgICAgICAgICAgIHJlY29ubmVjdERlbGF5ID0gMTAwMFxuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBcImhlYXJ0YmVhdFwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0g8J+SkyBIZWFydGJlYXQgcmVjZWl2ZWRcIilcbiAgICAgICAgICAgIHJlY29ubmVjdERlbGF5ID0gMTAwMFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0g4oS577iPIFVua25vd24gZXZlbnQgdHlwZTpcIiwgZXZlbnRUeXBlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgaWYgKGVycm9yLm5hbWUgIT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbU1NFLU1hbmFnZXJdIOKdjCBDb25uZWN0aW9uIGVycm9yOlwiLCBlcnJvcilcbiAgICAgICAgdGhpcy5lcnJvckxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaXN0ZW5lcihlcnJvcilcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbU1NFLU1hbmFnZXJdIEVycm9yIGluIGVycm9yIGxpc3RlbmVyOlwiLCBlcnIpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAvLyBBdXRvLXJlY29ubmVjdCBvbiBlcnJvclxuICAgICAgICBpZiAodGhpcy5zaG91bGRSZWNvbm5lY3QgJiYgdGhpcy5saXN0ZW5lcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlY29ubmVjdERlbGF5ID0gTWF0aC5taW4ocmVjb25uZWN0RGVsYXkgKiAyLCAzMDAwMClcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdEFzeW5jKClcbiAgICAgICAgICB9LCByZWNvbm5lY3REZWxheSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLnNob3VsZFJlY29ubmVjdCA9IGZhbHNlXG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgIFxuICAgIGlmICh0aGlzLmFib3J0Q29udHJvbGxlcikge1xuICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBudWxsXG4gICAgfVxuICAgIFxuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpXG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBudWxsXG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSBEaXNjb25uZWN0ZWQgZnJvbSBub3RpZmljYXRpb24gc3RyZWFtXCIpXG4gIH1cblxuICAvLyBQdWJsaWMgbWV0aG9kIHRvIG1hbnVhbGx5IGRpc2Nvbm5lY3QgKHdoZW4gdXNlciBsb2dzIG91dCwgZXRjLilcbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5jbGVhcigpXG4gICAgdGhpcy5lcnJvckxpc3RlbmVycy5jbGVhcigpXG4gICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0gRGVzdHJveWVkIGFsbCBjb25uZWN0aW9uc1wiKVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgY29ubmVjdGVkXG4gIGdldENvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0Nvbm5lY3RlZFxuICB9XG5cbiAgLy8gR2V0IGxpc3RlbmVyIGNvdW50XG4gIGdldExpc3RlbmVyQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLnNpemVcbiAgfVxufVxuXG4vLyBTaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBzc2VNYW5hZ2VyID0gbmV3IFNTRU1hbmFnZXIoKVxuXG4iXSwibmFtZXMiOlsiU1NFTWFuYWdlciIsImNvbm5lY3QiLCJvbk5vdGlmaWNhdGlvbiIsIm9uRXJyb3IiLCJjb25zb2xlIiwibG9nIiwibGlzdGVuZXJzIiwic2l6ZSIsImlzQ29ubmVjdGVkIiwiaXNDb25uZWN0aW5nIiwiYWRkIiwiZXJyb3JMaXN0ZW5lcnMiLCJ1bnN1YnNjcmliZSIsImRlbGV0ZSIsInNldFRpbWVvdXQiLCJkaXNjb25uZWN0Iiwic3RhcnRDb25uZWN0aW9uIiwid2FybiIsInRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImVycm9yIiwic2hvdWxkUmVjb25uZWN0IiwiY29ubmVjdEFzeW5jIiwiUHJvbWlzZSIsInJlc29sdmUiLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ1cmwiLCJhcGlCYXNlVXJsIiwicmVjb25uZWN0RGVsYXkiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJBY2NlcHQiLCJzaWduYWwiLCJvayIsIkVycm9yIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsInJlYWRlciIsImJvZHkiLCJnZXRSZWFkZXIiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJidWZmZXIiLCJkb25lIiwidmFsdWUiLCJyZWFkIiwicmVjb25uZWN0VGltZW91dCIsIk1hdGgiLCJtaW4iLCJkZWNvZGUiLCJzdHJlYW0iLCJpbmNsdWRlcyIsImVuZHNXaXRoIiwiZXZlbnRMaW5lcyIsImV2ZW50RW5kSW5kZXgiLCJpbmRleE9mIiwibGVuZ3RoIiwiZXZlbnRUZXh0Iiwic3Vic3RyaW5nIiwiZXZlbnRUeXBlIiwiZXZlbnREYXRhIiwic3BsaXQiLCJpIiwibGluZSIsInRyaW1tZWRMaW5lIiwidHJpbSIsImxvd2VyTGluZSIsInRvTG93ZXJDYXNlIiwic3RhcnRzV2l0aCIsImFmdGVyQ29sb24iLCJsaW5lRGF0YSIsInR5cGUiLCJoYXNEYXRhIiwiZGF0YUxlbmd0aCIsInJhd0xpbmVzIiwiZmlyc3RMaW5lIiwicHJldmlldyIsIm5vdGlmaWNhdGlvbiIsIkpTT04iLCJwYXJzZSIsImlkIiwidGl0bGUiLCJtZXNzYWdlIiwiY2F0ZWdvcnkiLCJsaXN0ZW5lcnNUb05vdGlmeSIsIkFycmF5IiwiZnJvbSIsImZvckVhY2giLCJsaXN0ZW5lciIsIm5hbWUiLCJlcnIiLCJhYm9ydCIsImNsZWFyVGltZW91dCIsImRlc3Ryb3kiLCJjbGVhciIsImdldENvbm5lY3RlZCIsImdldExpc3RlbmVyQ291bnQiLCJjb25zdHJ1Y3RvciIsIlNldCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwic3NlTWFuYWdlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api/sse-manager.ts\n"));

/***/ })

}]);