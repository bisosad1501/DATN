"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_ssr_lib_api_sse-manager_ts";
exports.ids = ["_ssr_lib_api_sse-manager_ts"];
exports.modules = {

/***/ "(ssr)/./lib/api/sse-manager.ts":
/*!********************************!*\
  !*** ./lib/api/sse-manager.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sseManager: () => (/* binding */ sseManager)\n/* harmony export */ });\nclass SSEManager {\n    constructor(){\n        this.abortController = null;\n        this.reconnectTimeout = null;\n        this.shouldReconnect = true;\n        this.listeners = new Set();\n        this.errorListeners = new Set();\n        this.isConnected = false;\n        this.isConnecting = false;\n        this.apiBaseUrl = \"http://localhost:8080/api/v1\" || 0;\n    }\n    connect(onNotification, onError) {\n        console.log(\"[SSE-Manager] connect() called, current listeners:\", this.listeners.size, \"connected:\", this.isConnected, \"connecting:\", this.isConnecting);\n        // Add listeners FIRST, before starting connection\n        // Set doesn't allow duplicates, so we don't need to check\n        this.listeners.add(onNotification);\n        if (onError) {\n            this.errorListeners.add(onError);\n        }\n        console.log(\"[SSE-Manager] After adding listener, total listeners:\", this.listeners.size);\n        // Create unsubscribe function FIRST (before any async operations)\n        const unsubscribe = ()=>{\n            console.log(\"[SSE-Manager] Unsubscribing listener, current count before:\", this.listeners.size);\n            this.listeners.delete(onNotification);\n            if (onError) {\n                this.errorListeners.delete(onError);\n            }\n            console.log(\"[SSE-Manager] After unsubscribe, listeners:\", this.listeners.size);\n            // Only disconnect if no listeners left\n            // Use longer delay to avoid race conditions when component re-renders quickly\n            if (this.listeners.size === 0) {\n                console.log(\"[SSE-Manager] No listeners left, scheduling disconnect in 500ms...\");\n                // Longer delay to avoid race conditions\n                setTimeout(()=>{\n                    // Double check - maybe a new listener was added during the delay\n                    if (this.listeners.size === 0) {\n                        console.log(\"[SSE-Manager] Confirmed no listeners, disconnecting...\");\n                        this.disconnect();\n                    } else {\n                        console.log(\"[SSE-Manager] New listener added during delay, keeping connection (listeners:\", this.listeners.size, \")\");\n                    }\n                }, 500);\n            }\n        };\n        // Start connection if not already connected or connecting\n        // Only create ONE connection regardless of how many listeners\n        // Use much longer timeout to handle React Strict Mode double-invoke cycle completely\n        if (!this.isConnected && !this.isConnecting) {\n            console.log(\"[SSE-Manager] Scheduling connection start (listeners:\", this.listeners.size, \")...\");\n            // Use longer delay (1200ms) to fully handle React Strict Mode double-invoke cycle\n            // React Strict Mode: mount → unmount → mount (takes ~200-500ms, but we need more buffer)\n            setTimeout(()=>{\n                // Double-check listeners before starting\n                if (this.listeners.size > 0 && !this.isConnected && !this.isConnecting) {\n                    console.log(\"[SSE-Manager] ✅ Starting connection now (listeners:\", this.listeners.size, \")...\");\n                    this.startConnection();\n                } else {\n                    console.log(\"[SSE-Manager] ⏭️ Skipping connection start (listeners:\", this.listeners.size, \"connected:\", this.isConnected, \"connecting:\", this.isConnecting, \")\");\n                }\n            }, 1200);\n        } else {\n            console.log(\"[SSE-Manager] Connection already exists, adding listener to existing connection (connected:\", this.isConnected, \"connecting:\", this.isConnecting, \")\");\n        }\n        // Return unsubscribe function (ALWAYS return a function)\n        console.log(\"[SSE-Manager] Returning unsubscribe function, type:\", typeof unsubscribe);\n        return unsubscribe;\n    }\n    startConnection() {\n        if (this.isConnected || this.isConnecting) {\n            console.log(\"[SSE-Manager] Already connected or connecting, skipping\");\n            return;\n        }\n        // Final check - ensure we have listeners before starting\n        if (this.listeners.size === 0) {\n            console.warn(\"[SSE-Manager] ⚠️ startConnection() called but no listeners, aborting\");\n            return;\n        }\n        const token =  false ? 0 : null;\n        if (!token) {\n            console.error(\"[SSE-Manager] No token available\");\n            return;\n        }\n        console.log(\"[SSE-Manager] ✅ Starting connection with\", this.listeners.size, \"listener(s)...\");\n        this.shouldReconnect = true;\n        // Call private async connectAsync() method\n        this.connectAsync();\n    }\n    async connectAsync() {\n        if (this.isConnecting || !this.shouldReconnect) {\n            console.log(\"[SSE-Manager] connect() called but already connecting or shouldReconnect=false\");\n            return;\n        }\n        // Double-check listeners before starting connection\n        // If no listeners, wait for React Strict Mode to finish\n        // Instead of aborting, we retry after a delay to handle React Strict Mode\n        if (this.listeners.size === 0) {\n            console.warn(\"[SSE-Manager] ⚠️ No listeners before starting connection, waiting 1500ms for React Strict Mode...\");\n            await new Promise((resolve)=>setTimeout(resolve, 1500));\n            if (this.listeners.size === 0) {\n                console.warn(\"[SSE-Manager] ⚠️ Still no listeners after wait - will retry connection attempt later\");\n                this.isConnecting = false;\n                // Retry connection after React Strict Mode cycle completes\n                // This ensures we don't permanently abort during development\n                setTimeout(()=>{\n                    if (this.listeners.size > 0 && !this.isConnected && !this.isConnecting) {\n                        console.log(\"[SSE-Manager] ✅ Retrying connection after React Strict Mode (listeners:\", this.listeners.size, \")\");\n                        this.startConnection();\n                    }\n                }, 2000);\n                return;\n            }\n            console.log(\"[SSE-Manager] ✅ Listeners registered after wait (count:\", this.listeners.size, \"), proceeding with connection\");\n        }\n        this.isConnecting = true;\n        this.abortController = new AbortController();\n        const token =  false ? 0 : null;\n        if (!token) {\n            console.error(\"[SSE-Manager] No token available\");\n            this.isConnecting = false;\n            return;\n        }\n        const url = `${this.apiBaseUrl}/notifications/stream`;\n        let reconnectDelay = 1000;\n        try {\n            console.log(\"[SSE-Manager] Fetching SSE stream, listeners:\", this.listeners.size);\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    Authorization: `Bearer ${token}`,\n                    Accept: \"text/event-stream\"\n                },\n                signal: this.abortController?.signal\n            });\n            if (!response.ok) {\n                throw new Error(`SSE connection failed: ${response.status} ${response.statusText}`);\n            }\n            const reader = response.body?.getReader();\n            const decoder = new TextDecoder();\n            if (!reader) {\n                throw new Error(\"No reader available\");\n            }\n            let buffer = \"\";\n            this.isConnecting = false;\n            this.isConnected = true;\n            console.log(\"[SSE-Manager] ✅ Connected to notification stream, listeners:\", this.listeners.size);\n            reconnectDelay = 1000;\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) {\n                    console.log(\"[SSE-Manager] ⚠️ Stream ended, reconnecting in\", reconnectDelay, \"ms...\");\n                    this.isConnected = false;\n                    this.isConnecting = false;\n                    if (this.shouldReconnect && this.listeners.size > 0) {\n                        this.reconnectTimeout = setTimeout(()=>{\n                            reconnectDelay = Math.min(reconnectDelay * 2, 30000);\n                            this.connectAsync();\n                        }, reconnectDelay);\n                    }\n                    break;\n                }\n                buffer += decoder.decode(value, {\n                    stream: true\n                });\n                // Process complete events (SSE format: event: <type>\\ndata: <data>\\n\\n)\n                while(buffer.includes(\"\\n\\n\") || buffer.includes(\"\\n\") && buffer.endsWith(\"\\n\")){\n                    let eventEndIndex = buffer.indexOf(\"\\n\\n\");\n                    if (eventEndIndex === -1 && buffer.endsWith(\"\\n\")) {\n                        eventEndIndex = buffer.length - 1;\n                    }\n                    if (eventEndIndex === -1) break;\n                    const eventText = buffer.substring(0, eventEndIndex);\n                    buffer = buffer.substring(eventEndIndex + 2);\n                    let eventType = \"message\" // Default SSE event type\n                    ;\n                    let eventData = \"\";\n                    // Parse SSE format lines (split by \\n or \\r\\n)\n                    const eventLines = eventText.split(/\\r?\\n/);\n                    for(let i = 0; i < eventLines.length; i++){\n                        const line = eventLines[i];\n                        const trimmedLine = line.trim();\n                        if (!trimmedLine) continue; // Skip empty lines\n                        const lowerLine = trimmedLine.toLowerCase();\n                        // Parse event type: \"event:connected\" or \"event: connected\" (case-insensitive)\n                        if (lowerLine.startsWith(\"event:\")) {\n                            const afterColon = trimmedLine.substring(6) // After \"event:\"\n                            ;\n                            eventType = afterColon.trim();\n                            console.log(\"[SSE-Manager] 🔍 Found event type:\", eventType, \"from line:\", line.substring(0, 50));\n                            continue;\n                        }\n                        // Parse data: \"data:{\\\"message\\\":\\\"...\\\"}\" or \"data: {\\\"message\\\":\\\"...\\\"}\" (case-insensitive)\n                        if (lowerLine.startsWith(\"data:\")) {\n                            const afterColon = trimmedLine.substring(5) // After \"data:\"\n                            ;\n                            const lineData = afterColon.trim();\n                            // Handle multi-line data (join with newline)\n                            if (eventData) {\n                                eventData += \"\\n\" + lineData;\n                            } else {\n                                eventData = lineData;\n                            }\n                            console.log(\"[SSE-Manager] 🔍 Found data line:\", lineData.substring(0, 50), \"...\");\n                            continue;\n                        }\n                    // Ignore other lines (comments starting with \":\", id, retry, etc.)\n                    }\n                    // Debug: Log what we parsed\n                    console.log(\"[SSE-Manager] 📦 Parsed SSE event:\", {\n                        type: eventType,\n                        hasData: !!eventData,\n                        dataLength: eventData.length,\n                        rawLines: eventLines.length,\n                        firstLine: eventLines[0]?.substring(0, 50),\n                        preview: eventText.substring(0, 200)\n                    });\n                    // Process event - only process if there's data\n                    if (!eventData) {\n                        // Skip events without data (like empty heartbeats or connection messages)\n                        if (eventType === \"heartbeat\" || eventType === \"connected\" || eventType === \"message\") {\n                            console.log(\"[SSE-Manager] ⏭️ Skipping empty\", eventType, \"event (no data)\");\n                        } else {\n                            console.log(\"[SSE-Manager] ⚠️ Received event with no data:\", eventType);\n                        }\n                        continue;\n                    }\n                    console.log(\"[SSE-Manager] 📥 Processing SSE event:\", {\n                        eventType,\n                        dataLength: eventData.length\n                    });\n                    if (eventType === \"notification\") {\n                        try {\n                            const notification = JSON.parse(eventData);\n                            console.log(\"[SSE-Manager] 📬 Parsed notification:\", {\n                                id: notification.id,\n                                title: notification.title,\n                                message: notification.message?.substring(0, 50),\n                                category: notification.category\n                            });\n                            reconnectDelay = 1000;\n                            // Notify all listeners - use Array.from to avoid iterator issues\n                            const listenersToNotify = Array.from(this.listeners);\n                            console.log(\"[SSE-Manager] 📢 Broadcasting to\", listenersToNotify.length, \"listener(s)\");\n                            // Notify listeners synchronously to ensure immediate delivery\n                            listenersToNotify.forEach((listener)=>{\n                                try {\n                                    console.log(\"[SSE-Manager] 📤 Calling listener with notification:\", notification.id);\n                                    listener(notification);\n                                    console.log(\"[SSE-Manager] ✅ Listener called successfully\");\n                                } catch (error) {\n                                    console.error(\"[SSE-Manager] ❌ Error in listener:\", error);\n                                }\n                            });\n                        } catch (error) {\n                            console.error(\"[SSE-Manager] ❌ Parse error:\", error, \"Event data:\", eventData);\n                        }\n                    } else if (eventType === \"connected\") {\n                        console.log(\"[SSE-Manager] ✅ Server confirmed connection\");\n                        reconnectDelay = 1000;\n                    } else if (eventType === \"heartbeat\") {\n                        console.log(\"[SSE-Manager] 💓 Heartbeat received\");\n                        reconnectDelay = 1000;\n                    } else {\n                        console.log(\"[SSE-Manager] ℹ️ Unknown event type:\", eventType);\n                    }\n                }\n            }\n        } catch (error) {\n            this.isConnected = false;\n            this.isConnecting = false;\n            if (error.name !== \"AbortError\") {\n                console.error(\"[SSE-Manager] ❌ Connection error:\", error);\n                this.errorListeners.forEach((listener)=>{\n                    try {\n                        listener(error);\n                    } catch (err) {\n                        console.error(\"[SSE-Manager] Error in error listener:\", err);\n                    }\n                });\n                // Auto-reconnect on error\n                if (this.shouldReconnect && this.listeners.size > 0) {\n                    this.reconnectTimeout = setTimeout(()=>{\n                        reconnectDelay = Math.min(reconnectDelay * 2, 30000);\n                        this.connectAsync();\n                    }, reconnectDelay);\n                }\n            }\n        }\n    }\n    disconnect() {\n        this.shouldReconnect = false;\n        this.isConnected = false;\n        this.isConnecting = false;\n        if (this.abortController) {\n            this.abortController.abort();\n            this.abortController = null;\n        }\n        if (this.reconnectTimeout) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n        }\n        console.log(\"[SSE-Manager] Disconnected from notification stream\");\n    }\n    // Public method to manually disconnect (when user logs out, etc.)\n    destroy() {\n        this.listeners.clear();\n        this.errorListeners.clear();\n        this.disconnect();\n        console.log(\"[SSE-Manager] Destroyed all connections\");\n    }\n    // Check if connected\n    getConnected() {\n        return this.isConnected;\n    }\n    // Get listener count\n    getListenerCount() {\n        return this.listeners.size;\n    }\n}\n// Singleton instance\nconst sseManager = new SSEManager();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O2dCQUNMO1lBQ0Y7UUFDRjtJQUNGO0lBRVFaLGFBQWE7UUFDbkIsSUFBSSxDQUFDcEIsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0ksV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBRXBCLElBQUksSUFBSSxDQUFDUCxlQUFlLEVBQUU7WUFDeEIsSUFBSSxDQUFDQSxlQUFlLENBQUNtRyxLQUFLO1lBQzFCLElBQUksQ0FBQ25HLGVBQWUsR0FBRztRQUN6QjtRQUVBLElBQUksSUFBSSxDQUFDQyxnQkFBZ0IsRUFBRTtZQUN6Qm1HLGFBQWEsSUFBSSxDQUFDbkcsZ0JBQWdCO1lBQ2xDLElBQUksQ0FBQ0EsZ0JBQWdCLEdBQUc7UUFDMUI7UUFFQWMsUUFBUUMsR0FBRyxDQUFDO0lBQ2Q7SUFFQSxrRUFBa0U7SUFDbEVxRixVQUFVO1FBQ1IsSUFBSSxDQUFDbEcsU0FBUyxDQUFDbUcsS0FBSztRQUNwQixJQUFJLENBQUNqRyxjQUFjLENBQUNpRyxLQUFLO1FBQ3pCLElBQUksQ0FBQ2hGLFVBQVU7UUFDZlAsUUFBUUMsR0FBRyxDQUFDO0lBQ2Q7SUFFQSxxQkFBcUI7SUFDckJ1RixlQUFlO1FBQ2IsT0FBTyxJQUFJLENBQUNqRyxXQUFXO0lBQ3pCO0lBRUEscUJBQXFCO0lBQ3JCa0csbUJBQW1CO1FBQ2pCLE9BQU8sSUFBSSxDQUFDckcsU0FBUyxDQUFDYyxJQUFJO0lBQzVCO0FBQ0Y7QUFFQSxxQkFBcUI7QUFDZCxNQUFNd0YsYUFBYSxJQUFJM0csYUFBWSIsInNvdXJjZXMiOlsiL1VzZXJzL2Jpc29zYWQvREFUTi9Gcm9udGVuZC1JRUxUU0dvL2xpYi9hcGkvc3NlLW1hbmFnZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBOb3RpZmljYXRpb24gfSBmcm9tIFwiQC90eXBlc1wiXG5cbnR5cGUgU1NFTGlzdGVuZXIgPSAobm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb24pID0+IHZvaWRcbnR5cGUgRXJyb3JMaXN0ZW5lciA9IChlcnJvcjogRXZlbnQgfCBFcnJvcikgPT4gdm9pZFxuXG5jbGFzcyBTU0VNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBhYm9ydENvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlciB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgcmVjb25uZWN0VGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbFxuICBwcml2YXRlIHNob3VsZFJlY29ubmVjdCA9IHRydWVcbiAgcHJpdmF0ZSBsaXN0ZW5lcnM6IFNldDxTU0VMaXN0ZW5lcj4gPSBuZXcgU2V0KClcbiAgcHJpdmF0ZSBlcnJvckxpc3RlbmVyczogU2V0PEVycm9yTGlzdGVuZXI+ID0gbmV3IFNldCgpXG4gIHByaXZhdGUgaXNDb25uZWN0ZWQgPSBmYWxzZVxuICBwcml2YXRlIGlzQ29ubmVjdGluZyA9IGZhbHNlXG4gIHByaXZhdGUgYXBpQmFzZVVybDogc3RyaW5nXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5hcGlCYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9hcGkvdjFcIlxuICB9XG5cbiAgY29ubmVjdChcbiAgICBvbk5vdGlmaWNhdGlvbjogU1NFTGlzdGVuZXIsXG4gICAgb25FcnJvcj86IEVycm9yTGlzdGVuZXJcbiAgKTogKCkgPT4gdm9pZCB7XG4gICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIGNvbm5lY3QoKSBjYWxsZWQsIGN1cnJlbnQgbGlzdGVuZXJzOlwiLCB0aGlzLmxpc3RlbmVycy5zaXplLCBcImNvbm5lY3RlZDpcIiwgdGhpcy5pc0Nvbm5lY3RlZCwgXCJjb25uZWN0aW5nOlwiLCB0aGlzLmlzQ29ubmVjdGluZylcbiAgICBcbiAgICAvLyBBZGQgbGlzdGVuZXJzIEZJUlNULCBiZWZvcmUgc3RhcnRpbmcgY29ubmVjdGlvblxuICAgIC8vIFNldCBkb2Vzbid0IGFsbG93IGR1cGxpY2F0ZXMsIHNvIHdlIGRvbid0IG5lZWQgdG8gY2hlY2tcbiAgICB0aGlzLmxpc3RlbmVycy5hZGQob25Ob3RpZmljYXRpb24pXG4gICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgIHRoaXMuZXJyb3JMaXN0ZW5lcnMuYWRkKG9uRXJyb3IpXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIEFmdGVyIGFkZGluZyBsaXN0ZW5lciwgdG90YWwgbGlzdGVuZXJzOlwiLCB0aGlzLmxpc3RlbmVycy5zaXplKVxuXG4gICAgLy8gQ3JlYXRlIHVuc3Vic2NyaWJlIGZ1bmN0aW9uIEZJUlNUIChiZWZvcmUgYW55IGFzeW5jIG9wZXJhdGlvbnMpXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0gVW5zdWJzY3JpYmluZyBsaXN0ZW5lciwgY3VycmVudCBjb3VudCBiZWZvcmU6XCIsIHRoaXMubGlzdGVuZXJzLnNpemUpXG4gICAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUob25Ob3RpZmljYXRpb24pXG4gICAgICBpZiAob25FcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yTGlzdGVuZXJzLmRlbGV0ZShvbkVycm9yKVxuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIEFmdGVyIHVuc3Vic2NyaWJlLCBsaXN0ZW5lcnM6XCIsIHRoaXMubGlzdGVuZXJzLnNpemUpXG4gICAgICBcbiAgICAgIC8vIE9ubHkgZGlzY29ubmVjdCBpZiBubyBsaXN0ZW5lcnMgbGVmdFxuICAgICAgLy8gVXNlIGxvbmdlciBkZWxheSB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnMgd2hlbiBjb21wb25lbnQgcmUtcmVuZGVycyBxdWlja2x5XG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0gTm8gbGlzdGVuZXJzIGxlZnQsIHNjaGVkdWxpbmcgZGlzY29ubmVjdCBpbiA1MDBtcy4uLlwiKVxuICAgICAgICAvLyBMb25nZXIgZGVsYXkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIC8vIERvdWJsZSBjaGVjayAtIG1heWJlIGEgbmV3IGxpc3RlbmVyIHdhcyBhZGRlZCBkdXJpbmcgdGhlIGRlbGF5XG4gICAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSBDb25maXJtZWQgbm8gbGlzdGVuZXJzLCBkaXNjb25uZWN0aW5nLi4uXCIpXG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0gTmV3IGxpc3RlbmVyIGFkZGVkIGR1cmluZyBkZWxheSwga2VlcGluZyBjb25uZWN0aW9uIChsaXN0ZW5lcnM6XCIsIHRoaXMubGlzdGVuZXJzLnNpemUsIFwiKVwiKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0YXJ0IGNvbm5lY3Rpb24gaWYgbm90IGFscmVhZHkgY29ubmVjdGVkIG9yIGNvbm5lY3RpbmdcbiAgICAvLyBPbmx5IGNyZWF0ZSBPTkUgY29ubmVjdGlvbiByZWdhcmRsZXNzIG9mIGhvdyBtYW55IGxpc3RlbmVyc1xuICAgIC8vIFVzZSBtdWNoIGxvbmdlciB0aW1lb3V0IHRvIGhhbmRsZSBSZWFjdCBTdHJpY3QgTW9kZSBkb3VibGUtaW52b2tlIGN5Y2xlIGNvbXBsZXRlbHlcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQgJiYgIXRoaXMuaXNDb25uZWN0aW5nKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0gU2NoZWR1bGluZyBjb25uZWN0aW9uIHN0YXJ0IChsaXN0ZW5lcnM6XCIsIHRoaXMubGlzdGVuZXJzLnNpemUsIFwiKS4uLlwiKVxuICAgICAgLy8gVXNlIGxvbmdlciBkZWxheSAoMTIwMG1zKSB0byBmdWxseSBoYW5kbGUgUmVhY3QgU3RyaWN0IE1vZGUgZG91YmxlLWludm9rZSBjeWNsZVxuICAgICAgLy8gUmVhY3QgU3RyaWN0IE1vZGU6IG1vdW50IOKGkiB1bm1vdW50IOKGkiBtb3VudCAodGFrZXMgfjIwMC01MDBtcywgYnV0IHdlIG5lZWQgbW9yZSBidWZmZXIpXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgLy8gRG91YmxlLWNoZWNrIGxpc3RlbmVycyBiZWZvcmUgc3RhcnRpbmdcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLnNpemUgPiAwICYmICF0aGlzLmlzQ29ubmVjdGVkICYmICF0aGlzLmlzQ29ubmVjdGluZykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSDinIUgU3RhcnRpbmcgY29ubmVjdGlvbiBub3cgKGxpc3RlbmVyczpcIiwgdGhpcy5saXN0ZW5lcnMuc2l6ZSwgXCIpLi4uXCIpXG4gICAgICAgICAgdGhpcy5zdGFydENvbm5lY3Rpb24oKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSDij63vuI8gU2tpcHBpbmcgY29ubmVjdGlvbiBzdGFydCAobGlzdGVuZXJzOlwiLCB0aGlzLmxpc3RlbmVycy5zaXplLCBcImNvbm5lY3RlZDpcIiwgdGhpcy5pc0Nvbm5lY3RlZCwgXCJjb25uZWN0aW5nOlwiLCB0aGlzLmlzQ29ubmVjdGluZywgXCIpXCIpXG4gICAgICAgIH1cbiAgICAgIH0sIDEyMDApXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSBDb25uZWN0aW9uIGFscmVhZHkgZXhpc3RzLCBhZGRpbmcgbGlzdGVuZXIgdG8gZXhpc3RpbmcgY29ubmVjdGlvbiAoY29ubmVjdGVkOlwiLCB0aGlzLmlzQ29ubmVjdGVkLCBcImNvbm5lY3Rpbmc6XCIsIHRoaXMuaXNDb25uZWN0aW5nLCBcIilcIilcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdW5zdWJzY3JpYmUgZnVuY3Rpb24gKEFMV0FZUyByZXR1cm4gYSBmdW5jdGlvbilcbiAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0gUmV0dXJuaW5nIHVuc3Vic2NyaWJlIGZ1bmN0aW9uLCB0eXBlOlwiLCB0eXBlb2YgdW5zdWJzY3JpYmUpXG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlXG4gIH1cblxuICBwcml2YXRlIHN0YXJ0Q29ubmVjdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCB8fCB0aGlzLmlzQ29ubmVjdGluZykge1xuICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIEFscmVhZHkgY29ubmVjdGVkIG9yIGNvbm5lY3RpbmcsIHNraXBwaW5nXCIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBGaW5hbCBjaGVjayAtIGVuc3VyZSB3ZSBoYXZlIGxpc3RlbmVycyBiZWZvcmUgc3RhcnRpbmdcbiAgICBpZiAodGhpcy5saXN0ZW5lcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1NTRS1NYW5hZ2VyXSDimqDvuI8gc3RhcnRDb25uZWN0aW9uKCkgY2FsbGVkIGJ1dCBubyBsaXN0ZW5lcnMsIGFib3J0aW5nXCIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB0b2tlbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImFjY2Vzc190b2tlblwiKSA6IG51bGxcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1NTRS1NYW5hZ2VyXSBObyB0b2tlbiBhdmFpbGFibGVcIilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSDinIUgU3RhcnRpbmcgY29ubmVjdGlvbiB3aXRoXCIsIHRoaXMubGlzdGVuZXJzLnNpemUsIFwibGlzdGVuZXIocykuLi5cIilcbiAgICB0aGlzLnNob3VsZFJlY29ubmVjdCA9IHRydWVcbiAgICAvLyBDYWxsIHByaXZhdGUgYXN5bmMgY29ubmVjdEFzeW5jKCkgbWV0aG9kXG4gICAgdGhpcy5jb25uZWN0QXN5bmMoKVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjb25uZWN0QXN5bmMoKSB7XG4gICAgaWYgKHRoaXMuaXNDb25uZWN0aW5nIHx8ICF0aGlzLnNob3VsZFJlY29ubmVjdCkge1xuICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIGNvbm5lY3QoKSBjYWxsZWQgYnV0IGFscmVhZHkgY29ubmVjdGluZyBvciBzaG91bGRSZWNvbm5lY3Q9ZmFsc2VcIilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIERvdWJsZS1jaGVjayBsaXN0ZW5lcnMgYmVmb3JlIHN0YXJ0aW5nIGNvbm5lY3Rpb25cbiAgICAvLyBJZiBubyBsaXN0ZW5lcnMsIHdhaXQgZm9yIFJlYWN0IFN0cmljdCBNb2RlIHRvIGZpbmlzaFxuICAgIC8vIEluc3RlYWQgb2YgYWJvcnRpbmcsIHdlIHJldHJ5IGFmdGVyIGEgZGVsYXkgdG8gaGFuZGxlIFJlYWN0IFN0cmljdCBNb2RlXG4gICAgaWYgKHRoaXMubGlzdGVuZXJzLnNpemUgPT09IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltTU0UtTWFuYWdlcl0g4pqg77iPIE5vIGxpc3RlbmVycyBiZWZvcmUgc3RhcnRpbmcgY29ubmVjdGlvbiwgd2FpdGluZyAxNTAwbXMgZm9yIFJlYWN0IFN0cmljdCBNb2RlLi4uXCIpXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTUwMCkpXG4gICAgICBcbiAgICAgIGlmICh0aGlzLmxpc3RlbmVycy5zaXplID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltTU0UtTWFuYWdlcl0g4pqg77iPIFN0aWxsIG5vIGxpc3RlbmVycyBhZnRlciB3YWl0IC0gd2lsbCByZXRyeSBjb25uZWN0aW9uIGF0dGVtcHQgbGF0ZXJcIilcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgICAvLyBSZXRyeSBjb25uZWN0aW9uIGFmdGVyIFJlYWN0IFN0cmljdCBNb2RlIGN5Y2xlIGNvbXBsZXRlc1xuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgd2UgZG9uJ3QgcGVybWFuZW50bHkgYWJvcnQgZHVyaW5nIGRldmVsb3BtZW50XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmVycy5zaXplID4gMCAmJiAhdGhpcy5pc0Nvbm5lY3RlZCAmJiAhdGhpcy5pc0Nvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSDinIUgUmV0cnlpbmcgY29ubmVjdGlvbiBhZnRlciBSZWFjdCBTdHJpY3QgTW9kZSAobGlzdGVuZXJzOlwiLCB0aGlzLmxpc3RlbmVycy5zaXplLCBcIilcIilcbiAgICAgICAgICAgIHRoaXMuc3RhcnRDb25uZWN0aW9uKClcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDIwMDApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIOKchSBMaXN0ZW5lcnMgcmVnaXN0ZXJlZCBhZnRlciB3YWl0IChjb3VudDpcIiwgdGhpcy5saXN0ZW5lcnMuc2l6ZSwgXCIpLCBwcm9jZWVkaW5nIHdpdGggY29ubmVjdGlvblwiKVxuICAgIH1cblxuXG4gICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSB0cnVlXG4gICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICBjb25zdCB0b2tlbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImFjY2Vzc190b2tlblwiKSA6IG51bGxcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1NTRS1NYW5hZ2VyXSBObyB0b2tlbiBhdmFpbGFibGVcIilcbiAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2VcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpQmFzZVVybH0vbm90aWZpY2F0aW9ucy9zdHJlYW1gXG4gICAgbGV0IHJlY29ubmVjdERlbGF5ID0gMTAwMFxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSBGZXRjaGluZyBTU0Ugc3RyZWFtLCBsaXN0ZW5lcnM6XCIsIHRoaXMubGlzdGVuZXJzLnNpemUpXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICBBY2NlcHQ6IFwidGV4dC9ldmVudC1zdHJlYW1cIixcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmFsOiB0aGlzLmFib3J0Q29udHJvbGxlcj8uc2lnbmFsLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNTRSBjb25uZWN0aW9uIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5Py5nZXRSZWFkZXIoKVxuICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG5cbiAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlYWRlciBhdmFpbGFibGVcIilcbiAgICAgIH1cblxuICAgICAgbGV0IGJ1ZmZlciA9IFwiXCJcbiAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2VcbiAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlXG4gICAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0g4pyFIENvbm5lY3RlZCB0byBub3RpZmljYXRpb24gc3RyZWFtLCBsaXN0ZW5lcnM6XCIsIHRoaXMubGlzdGVuZXJzLnNpemUpXG5cbiAgICAgIHJlY29ubmVjdERlbGF5ID0gMTAwMFxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpXG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIOKaoO+4jyBTdHJlYW0gZW5kZWQsIHJlY29ubmVjdGluZyBpblwiLCByZWNvbm5lY3REZWxheSwgXCJtcy4uLlwiKVxuICAgICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2VcbiAgICAgICAgICBpZiAodGhpcy5zaG91bGRSZWNvbm5lY3QgJiYgdGhpcy5saXN0ZW5lcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICByZWNvbm5lY3REZWxheSA9IE1hdGgubWluKHJlY29ubmVjdERlbGF5ICogMiwgMzAwMDApXG4gICAgICAgICAgICAgIHRoaXMuY29ubmVjdEFzeW5jKClcbiAgICAgICAgICAgIH0sIHJlY29ubmVjdERlbGF5KVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmZmVyICs9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogdHJ1ZSB9KVxuXG4gICAgICAgIC8vIFByb2Nlc3MgY29tcGxldGUgZXZlbnRzIChTU0UgZm9ybWF0OiBldmVudDogPHR5cGU+XFxuZGF0YTogPGRhdGE+XFxuXFxuKVxuICAgICAgICB3aGlsZSAoYnVmZmVyLmluY2x1ZGVzKFwiXFxuXFxuXCIpIHx8IChidWZmZXIuaW5jbHVkZXMoXCJcXG5cIikgJiYgYnVmZmVyLmVuZHNXaXRoKFwiXFxuXCIpKSkge1xuICAgICAgICAgIGxldCBldmVudEVuZEluZGV4ID0gYnVmZmVyLmluZGV4T2YoXCJcXG5cXG5cIilcbiAgICAgICAgICBpZiAoZXZlbnRFbmRJbmRleCA9PT0gLTEgJiYgYnVmZmVyLmVuZHNXaXRoKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICBldmVudEVuZEluZGV4ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXZlbnRFbmRJbmRleCA9PT0gLTEpIGJyZWFrXG5cbiAgICAgICAgICBjb25zdCBldmVudFRleHQgPSBidWZmZXIuc3Vic3RyaW5nKDAsIGV2ZW50RW5kSW5kZXgpXG4gICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnN1YnN0cmluZyhldmVudEVuZEluZGV4ICsgMilcblxuICAgICAgICAgIGxldCBldmVudFR5cGUgPSBcIm1lc3NhZ2VcIiAvLyBEZWZhdWx0IFNTRSBldmVudCB0eXBlXG4gICAgICAgICAgbGV0IGV2ZW50RGF0YSA9IFwiXCJcblxuICAgICAgICAgIC8vIFBhcnNlIFNTRSBmb3JtYXQgbGluZXMgKHNwbGl0IGJ5IFxcbiBvciBcXHJcXG4pXG4gICAgICAgICAgY29uc3QgZXZlbnRMaW5lcyA9IGV2ZW50VGV4dC5zcGxpdCgvXFxyP1xcbi8pXG4gICAgICAgICAgXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gZXZlbnRMaW5lc1tpXVxuICAgICAgICAgICAgY29uc3QgdHJpbW1lZExpbmUgPSBsaW5lLnRyaW0oKVxuICAgICAgICAgICAgaWYgKCF0cmltbWVkTGluZSkgY29udGludWUgLy8gU2tpcCBlbXB0eSBsaW5lc1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBsb3dlckxpbmUgPSB0cmltbWVkTGluZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFBhcnNlIGV2ZW50IHR5cGU6IFwiZXZlbnQ6Y29ubmVjdGVkXCIgb3IgXCJldmVudDogY29ubmVjdGVkXCIgKGNhc2UtaW5zZW5zaXRpdmUpXG4gICAgICAgICAgICBpZiAobG93ZXJMaW5lLnN0YXJ0c1dpdGgoXCJldmVudDpcIikpIHtcbiAgICAgICAgICAgICAgY29uc3QgYWZ0ZXJDb2xvbiA9IHRyaW1tZWRMaW5lLnN1YnN0cmluZyg2KSAvLyBBZnRlciBcImV2ZW50OlwiXG4gICAgICAgICAgICAgIGV2ZW50VHlwZSA9IGFmdGVyQ29sb24udHJpbSgpXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSDwn5SNIEZvdW5kIGV2ZW50IHR5cGU6XCIsIGV2ZW50VHlwZSwgXCJmcm9tIGxpbmU6XCIsIGxpbmUuc3Vic3RyaW5nKDAsIDUwKSlcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUGFyc2UgZGF0YTogXCJkYXRhOntcXFwibWVzc2FnZVxcXCI6XFxcIi4uLlxcXCJ9XCIgb3IgXCJkYXRhOiB7XFxcIm1lc3NhZ2VcXFwiOlxcXCIuLi5cXFwifVwiIChjYXNlLWluc2Vuc2l0aXZlKVxuICAgICAgICAgICAgaWYgKGxvd2VyTGluZS5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICAgICAgICAgICAgY29uc3QgYWZ0ZXJDb2xvbiA9IHRyaW1tZWRMaW5lLnN1YnN0cmluZyg1KSAvLyBBZnRlciBcImRhdGE6XCJcbiAgICAgICAgICAgICAgY29uc3QgbGluZURhdGEgPSBhZnRlckNvbG9uLnRyaW0oKVxuICAgICAgICAgICAgICAvLyBIYW5kbGUgbXVsdGktbGluZSBkYXRhIChqb2luIHdpdGggbmV3bGluZSlcbiAgICAgICAgICAgICAgaWYgKGV2ZW50RGF0YSkge1xuICAgICAgICAgICAgICAgIGV2ZW50RGF0YSArPSBcIlxcblwiICsgbGluZURhdGFcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBldmVudERhdGEgPSBsaW5lRGF0YVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSDwn5SNIEZvdW5kIGRhdGEgbGluZTpcIiwgbGluZURhdGEuc3Vic3RyaW5nKDAsIDUwKSwgXCIuLi5cIilcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWdub3JlIG90aGVyIGxpbmVzIChjb21tZW50cyBzdGFydGluZyB3aXRoIFwiOlwiLCBpZCwgcmV0cnksIGV0Yy4pXG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIERlYnVnOiBMb2cgd2hhdCB3ZSBwYXJzZWRcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0g8J+TpiBQYXJzZWQgU1NFIGV2ZW50OlwiLCB7XG4gICAgICAgICAgICB0eXBlOiBldmVudFR5cGUsXG4gICAgICAgICAgICBoYXNEYXRhOiAhIWV2ZW50RGF0YSxcbiAgICAgICAgICAgIGRhdGFMZW5ndGg6IGV2ZW50RGF0YS5sZW5ndGgsXG4gICAgICAgICAgICByYXdMaW5lczogZXZlbnRMaW5lcy5sZW5ndGgsXG4gICAgICAgICAgICBmaXJzdExpbmU6IGV2ZW50TGluZXNbMF0/LnN1YnN0cmluZygwLCA1MCksXG4gICAgICAgICAgICBwcmV2aWV3OiBldmVudFRleHQuc3Vic3RyaW5nKDAsIDIwMCksXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIC8vIFByb2Nlc3MgZXZlbnQgLSBvbmx5IHByb2Nlc3MgaWYgdGhlcmUncyBkYXRhXG4gICAgICAgICAgaWYgKCFldmVudERhdGEpIHtcbiAgICAgICAgICAgIC8vIFNraXAgZXZlbnRzIHdpdGhvdXQgZGF0YSAobGlrZSBlbXB0eSBoZWFydGJlYXRzIG9yIGNvbm5lY3Rpb24gbWVzc2FnZXMpXG4gICAgICAgICAgICBpZiAoZXZlbnRUeXBlID09PSBcImhlYXJ0YmVhdFwiIHx8IGV2ZW50VHlwZSA9PT0gXCJjb25uZWN0ZWRcIiB8fCBldmVudFR5cGUgPT09IFwibWVzc2FnZVwiKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSDij63vuI8gU2tpcHBpbmcgZW1wdHlcIiwgZXZlbnRUeXBlLCBcImV2ZW50IChubyBkYXRhKVwiKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIOKaoO+4jyBSZWNlaXZlZCBldmVudCB3aXRoIG5vIGRhdGE6XCIsIGV2ZW50VHlwZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSDwn5OlIFByb2Nlc3NpbmcgU1NFIGV2ZW50OlwiLCB7IGV2ZW50VHlwZSwgZGF0YUxlbmd0aDogZXZlbnREYXRhLmxlbmd0aCB9KVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChldmVudFR5cGUgPT09IFwibm90aWZpY2F0aW9uXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IEpTT04ucGFyc2UoZXZlbnREYXRhKSBhcyBOb3RpZmljYXRpb25cbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIPCfk6wgUGFyc2VkIG5vdGlmaWNhdGlvbjpcIiwge1xuICAgICAgICAgICAgICAgIGlkOiBub3RpZmljYXRpb24uaWQsXG4gICAgICAgICAgICAgICAgdGl0bGU6IG5vdGlmaWNhdGlvbi50aXRsZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBub3RpZmljYXRpb24ubWVzc2FnZT8uc3Vic3RyaW5nKDAsIDUwKSxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeTogbm90aWZpY2F0aW9uLmNhdGVnb3J5LFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZWNvbm5lY3REZWxheSA9IDEwMDBcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIE5vdGlmeSBhbGwgbGlzdGVuZXJzIC0gdXNlIEFycmF5LmZyb20gdG8gYXZvaWQgaXRlcmF0b3IgaXNzdWVzXG4gICAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyc1RvTm90aWZ5ID0gQXJyYXkuZnJvbSh0aGlzLmxpc3RlbmVycylcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIPCfk6IgQnJvYWRjYXN0aW5nIHRvXCIsIGxpc3RlbmVyc1RvTm90aWZ5Lmxlbmd0aCwgXCJsaXN0ZW5lcihzKVwiKVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gTm90aWZ5IGxpc3RlbmVycyBzeW5jaHJvbm91c2x5IHRvIGVuc3VyZSBpbW1lZGlhdGUgZGVsaXZlcnlcbiAgICAgICAgICAgICAgbGlzdGVuZXJzVG9Ob3RpZnkuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIPCfk6QgQ2FsbGluZyBsaXN0ZW5lciB3aXRoIG5vdGlmaWNhdGlvbjpcIiwgbm90aWZpY2F0aW9uLmlkKVxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIobm90aWZpY2F0aW9uKVxuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIOKchSBMaXN0ZW5lciBjYWxsZWQgc3VjY2Vzc2Z1bGx5XCIpXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbU1NFLU1hbmFnZXJdIOKdjCBFcnJvciBpbiBsaXN0ZW5lcjpcIiwgZXJyb3IpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltTU0UtTWFuYWdlcl0g4p2MIFBhcnNlIGVycm9yOlwiLCBlcnJvciwgXCJFdmVudCBkYXRhOlwiLCBldmVudERhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1NTRS1NYW5hZ2VyXSDinIUgU2VydmVyIGNvbmZpcm1lZCBjb25uZWN0aW9uXCIpXG4gICAgICAgICAgICByZWNvbm5lY3REZWxheSA9IDEwMDBcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gXCJoZWFydGJlYXRcIikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIPCfkpMgSGVhcnRiZWF0IHJlY2VpdmVkXCIpXG4gICAgICAgICAgICByZWNvbm5lY3REZWxheSA9IDEwMDBcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIOKEue+4jyBVbmtub3duIGV2ZW50IHR5cGU6XCIsIGV2ZW50VHlwZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2VcbiAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2VcbiAgICAgIGlmIChlcnJvci5uYW1lICE9PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiW1NTRS1NYW5hZ2VyXSDinYwgQ29ubmVjdGlvbiBlcnJvcjpcIiwgZXJyb3IpXG4gICAgICAgIHRoaXMuZXJyb3JMaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGlzdGVuZXIoZXJyb3IpXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW1NTRS1NYW5hZ2VyXSBFcnJvciBpbiBlcnJvciBsaXN0ZW5lcjpcIiwgZXJyKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLy8gQXV0by1yZWNvbm5lY3Qgb24gZXJyb3JcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkUmVjb25uZWN0ICYmIHRoaXMubGlzdGVuZXJzLnNpemUgPiAwKSB7XG4gICAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZWNvbm5lY3REZWxheSA9IE1hdGgubWluKHJlY29ubmVjdERlbGF5ICogMiwgMzAwMDApXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RBc3luYygpXG4gICAgICAgICAgfSwgcmVjb25uZWN0RGVsYXkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5zaG91bGRSZWNvbm5lY3QgPSBmYWxzZVxuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZVxuICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2VcbiAgICBcbiAgICBpZiAodGhpcy5hYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KClcbiAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbnVsbFxuICAgIH1cbiAgICBcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lb3V0KVxuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gbnVsbFxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhcIltTU0UtTWFuYWdlcl0gRGlzY29ubmVjdGVkIGZyb20gbm90aWZpY2F0aW9uIHN0cmVhbVwiKVxuICB9XG5cbiAgLy8gUHVibGljIG1ldGhvZCB0byBtYW51YWxseSBkaXNjb25uZWN0ICh3aGVuIHVzZXIgbG9ncyBvdXQsIGV0Yy4pXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuY2xlYXIoKVxuICAgIHRoaXMuZXJyb3JMaXN0ZW5lcnMuY2xlYXIoKVxuICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgY29uc29sZS5sb2coXCJbU1NFLU1hbmFnZXJdIERlc3Ryb3llZCBhbGwgY29ubmVjdGlvbnNcIilcbiAgfVxuXG4gIC8vIENoZWNrIGlmIGNvbm5lY3RlZFxuICBnZXRDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNDb25uZWN0ZWRcbiAgfVxuXG4gIC8vIEdldCBsaXN0ZW5lciBjb3VudFxuICBnZXRMaXN0ZW5lckNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5zaXplXG4gIH1cbn1cblxuLy8gU2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3Qgc3NlTWFuYWdlciA9IG5ldyBTU0VNYW5hZ2VyKClcblxuIl0sIm5hbWVzIjpbIlNTRU1hbmFnZXIiLCJjb25zdHJ1Y3RvciIsImFib3J0Q29udHJvbGxlciIsInJlY29ubmVjdFRpbWVvdXQiLCJzaG91bGRSZWNvbm5lY3QiLCJsaXN0ZW5lcnMiLCJTZXQiLCJlcnJvckxpc3RlbmVycyIsImlzQ29ubmVjdGVkIiwiaXNDb25uZWN0aW5nIiwiYXBpQmFzZVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiY29ubmVjdCIsIm9uTm90aWZpY2F0aW9uIiwib25FcnJvciIsImNvbnNvbGUiLCJsb2ciLCJzaXplIiwiYWRkIiwidW5zdWJzY3JpYmUiLCJkZWxldGUiLCJzZXRUaW1lb3V0IiwiZGlzY29ubmVjdCIsInN0YXJ0Q29ubmVjdGlvbiIsIndhcm4iLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJlcnJvciIsImNvbm5lY3RBc3luYyIsIlByb21pc2UiLCJyZXNvbHZlIiwiQWJvcnRDb250cm9sbGVyIiwidXJsIiwicmVjb25uZWN0RGVsYXkiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJBY2NlcHQiLCJzaWduYWwiLCJvayIsIkVycm9yIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsInJlYWRlciIsImJvZHkiLCJnZXRSZWFkZXIiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJidWZmZXIiLCJkb25lIiwidmFsdWUiLCJyZWFkIiwiTWF0aCIsIm1pbiIsImRlY29kZSIsInN0cmVhbSIsImluY2x1ZGVzIiwiZW5kc1dpdGgiLCJldmVudEVuZEluZGV4IiwiaW5kZXhPZiIsImxlbmd0aCIsImV2ZW50VGV4dCIsInN1YnN0cmluZyIsImV2ZW50VHlwZSIsImV2ZW50RGF0YSIsImV2ZW50TGluZXMiLCJzcGxpdCIsImkiLCJsaW5lIiwidHJpbW1lZExpbmUiLCJ0cmltIiwibG93ZXJMaW5lIiwidG9Mb3dlckNhc2UiLCJzdGFydHNXaXRoIiwiYWZ0ZXJDb2xvbiIsImxpbmVEYXRhIiwidHlwZSIsImhhc0RhdGEiLCJkYXRhTGVuZ3RoIiwicmF3TGluZXMiLCJmaXJzdExpbmUiLCJwcmV2aWV3Iiwibm90aWZpY2F0aW9uIiwiSlNPTiIsInBhcnNlIiwiaWQiLCJ0aXRsZSIsIm1lc3NhZ2UiLCJjYXRlZ29yeSIsImxpc3RlbmVyc1RvTm90aWZ5IiwiQXJyYXkiLCJmcm9tIiwiZm9yRWFjaCIsImxpc3RlbmVyIiwibmFtZSIsImVyciIsImFib3J0IiwiY2xlYXJUaW1lb3V0IiwiZGVzdHJveSIsImNsZWFyIiwiZ2V0Q29ubmVjdGVkIiwiZ2V0TGlzdGVuZXJDb3VudCIsInNzZU1hbmFnZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./lib/api/sse-manager.ts\n");

/***/ })

};
;